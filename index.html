<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crucigramas IA</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Estilos personalizados para el fondo animado y glassmorphism */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Orbitron:wght@400;700&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d0d1a;
            color: #e0e0ff;
            overflow: hidden;
            background-image:
                linear-gradient(rgba(173, 216, 230, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(173, 216, 230, 0.1) 1px, transparent 1px);
            background-size: 100px 100px;
            animation: moveGrid 30s linear infinite;
        }

        .animated-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: -1;
        }

        .neon-bar {
            position: absolute;
            width: 2px;
            background: linear-gradient(to bottom, transparent, #00ffff, #ff00ff, transparent);
            animation: moveBar 10s linear infinite, glow 2s ease-in-out infinite alternate;
        }
        
        @keyframes moveGrid {
            from {
                background-position: 0 0;
            }
            to {
                background-position: 100px 100px;
            }
        }

        @keyframes moveBar {
            0% { transform: translateY(-100%); }
            100% { transform: translateY(100vh); }
        }

        @keyframes glow {
            0% { filter: drop-shadow(0 0 5px #00ffff) drop-shadow(0 0 10px #00ffff); opacity: 0.8; }
            100% { filter: drop-shadow(0 0 10px #ff00ff) drop-shadow(0 0 20px #ff00ff); opacity: 1; }
        }

        .glassy {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            border-radius: 20px;
            transition: all 0.3s ease;
        }

        .glassy-btn {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 10px 0 rgba(31, 38, 135, 0.1);
            transition: all 0.2s ease;
        }

        .glassy-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 6px 15px 0 rgba(31, 38, 135, 0.2);
        }

        .glassy-btn:active {
            transform: translateY(0);
        }
        
        /* Oculta la barra de scroll, pero mantiene la funcionalidad */
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }
        
        /* Estilos del tablero */
        .cell {
            width: 100%;
            padding-bottom: 100%; /* Truco para celdas cuadradas */
            position: relative;
        }

        .cell-inner {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.25rem;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        .correct {
            background-color: #34d399 !important; /* Tailwind green-400 */
        }

        .incorrect {
            background-color: #f87171 !important; /* Tailwind red-400 */
        }

        .complete {
            background-color: #2563eb !important; /* Tailwind blue-600 */
        }

    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
</head>
<body class="flex items-center justify-center min-h-screen p-4 overflow-y-auto">
    <!-- Fondo animado -->
    <div class="animated-bg"></div>

    <!-- Contenedor principal de la aplicación -->
    <main id="app-container" class="w-full max-w-4xl p-6 md:p-8 glassy">
        <!-- El contenido se renderizará aquí dinámicamente -->
    </main>

    <!-- Script principal de la aplicación -->
    <script>
        // Configuración de la aplicación
        const APP_CONFIG = {
            appName: 'Crucigramas IA',
            gridSize: 15,
            wordsPerLevel: 10,
            survivalLives: 5,
            maxAids: 3,
            languages: {
                es: {
                    title: 'Crucigramas IA',
                    play: 'Jugar',
                    options: 'Opciones',
                    casual: 'Modo Casual',
                    survival: 'Modo Supervivencia',
                    selectCategory: 'Selecciona una categoría:',
                    selectDifficulty: 'Selecciona la dificultad:',
                    difficultyLevels: ['1 (Fácil)', '2', '3', '4', '5 (Difícil)'],
                    enterTheme: 'Ingresa un tema:',
                    startGame: 'Empezar Juego',
                    horizontal: 'Horizontal',
                    vertical: 'Vertical',
                    aidsLeft: 'Ayudas restantes:',
                    helpIA: 'Ayúdame IA',
                    timer: 'Tiempo:',
                    lives: 'Vidas:',
                    errors: 'Errores:',
                    gameOverTitle: '¡Juego Terminado!',
                    gameOverMessage: 'Has perdido todas tus vidas.',
                    winTitle: '¡Felicidades, campeón!',
                    winMessage: 'Has completado todos los niveles.',
                    restart: 'Reiniciar',
                    backToMenu: 'Volver al Menú',
                    wordleMsgCorrect: '¡Correcto!',
                    wordleMsgIncorrect: 'Incorrecto.',
                    category: 'Categoría',
                    theme: 'Tema',
                    winLevel: 'Nivel completado.',
                    nextLevel: 'Siguiente Nivel',
                    langSelect: 'Idioma:',
                    regionSelect: 'Región:',
                    regionOptions: ['México', 'España', 'Argentina'],
                    other: 'Otro',
                    loading: 'Generando crucigrama...',
                    wordExists: 'La palabra ya ha sido usada.',
                    noWords: 'No se pudieron generar palabras para este tema. Intenta con otro.'
                },
                en: {
                    title: 'AI Crosswords',
                    play: 'Play',
                    options: 'Options',
                    casual: 'Casual Mode',
                    survival: 'Survival Mode',
                    selectCategory: 'Select a category:',
                    selectDifficulty: 'Select difficulty:',
                    difficultyLevels: ['1 (Easy)', '2', '3', '4', '5 (Hard)'],
                    enterTheme: 'Enter a theme:',
                    startGame: 'Start Game',
                    horizontal: 'Across',
                    vertical: 'Down',
                    aidsLeft: 'Aids left:',
                    helpIA: 'Help Me AI',
                    timer: 'Time:',
                    lives: 'Lives:',
                    errors: 'Errors:',
                    gameOverTitle: 'Game Over!',
                    gameOverMessage: 'You have lost all your lives.',
                    winTitle: 'Congratulations, Champion!',
                    winMessage: 'You have completed all levels.',
                    restart: 'Restart',
                    backToMenu: 'Back to Menu',
                    wordleMsgCorrect: 'Correct!',
                    wordleMsgIncorrect: 'Incorrect.',
                    category: 'Category',
                    theme: 'Theme',
                    winLevel: 'Level completed.',
                    nextLevel: 'Next Level',
                    langSelect: 'Language:',
                    regionSelect: 'Region:',
                    regionOptions: ['Mexico', 'Spain', 'Argentina'],
                    other: 'Other',
                    loading: 'Generating crossword...',
                    wordExists: 'The word has already been used.',
                    noWords: 'Could not generate words for this theme. Try another one.'
                }
            },
            categories: ['Animales', 'Ciencia', 'Historia', 'Cultura Pop', 'Tecnología', 'Geografía']
        };

        let state = {
            screen: 'mainMenu',
            language: 'es',
            region: 'México',
            gameMode: null,
            difficulty: 1,
            category: null,
            theme: null,
            grid: [],
            words: [],
            selectedWord: null,
            selectedCell: null,
            aidsLeft: 0,
            lives: APP_CONFIG.survivalLives,
            level: 1,
            errors: 0,
            timer: 0,
            timerInterval: null
        };
        
        let usedWordsInSession = new Set();
        
        /**
         * Llama a la API de Gemini para generar un array de objetos JSON para el crucigrama.
         * La respuesta se analiza y se devuelve como una lista de palabras.
         * @param {string} theme El tema para las palabras del crucigrama.
         * @param {number} level La dificultad del crucigrama (1-5).
         * @param {string} language El idioma para las palabras y pistas.
         * @returns {Promise<Array>} Un array de objetos con `word`, `clue`.
         */
        const getWordsFromAI = async (theme, level, language) => {
            const minLength = 4 + (level - 1);
            const maxLength = 10 + (level - 1);
            const wordsToAvoid = Array.from(usedWordsInSession).join(', ');

            const prompt = `
                Genera un array de ${APP_CONFIG.wordsPerLevel} objetos JSON para un crucigrama sobre el tema de "${theme}" en el idioma "${language}".
                La dificultad es nivel ${level} (1 es fácil, 5 es difícil).
                Las palabras deben tener entre ${minLength} y ${maxLength} letras.
                Las palabras no deben ser: [${wordsToAvoid}].
                Cada objeto debe tener los campos: "word" (la palabra en mayúsculas, sin tildes ni caracteres especiales) y "clue" (una pista concisa en español).

                Ejemplo de salida (NO USAR ESTO, es solo para formato):
                [
                    {"word": "COMPUTADORA", "clue": "Máquina electrónica que procesa datos."},
                    {"word": "CODIGO", "clue": "Conjunto de instrucciones para un programa."}
                ]
            `;

            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });
            
            const payload = {
                contents: chatHistory,
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "ARRAY",
                        items: {
                            type: "OBJECT",
                            properties: {
                                "word": { "type": "STRING" },
                                "clue": { "type": "STRING" }
                            },
                            "required": ["word", "clue"]
                        }
                    }
                }
            };
            
            const apiKey = "";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) {
                    throw new Error(`API call failed with status: ${response.status} - ${response.statusText}`);
                }

                const result = await response.json();
                console.log("Respuesta del API:", result);

                if (!result.candidates || result.candidates.length === 0 || !result.candidates[0].content || !result.candidates[0].content.parts || result.candidates[0].content.parts.length === 0) {
                    throw new Error("Respuesta del API no válida o incompleta.");
                }

                const jsonString = result.candidates[0].content.parts[0].text;
                const words = JSON.parse(jsonString);
                
                // Filtrar palabras ya usadas y agregar nuevas a la lista de palabras usadas
                const newWords = words.filter(item => {
                    if (!usedWordsInSession.has(item.word.toUpperCase())) {
                        usedWordsInSession.add(item.word.toUpperCase());
                        return true;
                    }
                    return false;
                });
                return newWords;

            } catch (error) {
                console.error("Error al generar el crucigrama:", error);
                // Manejar errores de forma elegante en la UI
                return [];
            }
        };

        // --- LÓGICA DE CONSTRUCCIÓN DEL CRUCIGRAMA ---
        // Esta sección ha sido reescrita para ser más robusta y fiable.
        
        /**
         * Inicializa una cuadrícula vacía para el juego.
         * @param {number} size El tamaño de la cuadrícula (N x N).
         * @returns {Array<Array<Object>>} La cuadrícula inicializada.
         */
        const initializeGrid = (size) => {
            const grid = Array.from({ length: size }, () =>
                Array.from({ length: size }, () => ({ letter: '', clueNumber: null, input: '' }))
            );
            return grid;
        };

        /**
         * Intenta colocar una lista de palabras en la cuadrícula de forma interconectada.
         * @param {Array<Object>} wordsData La lista de palabras y pistas de la IA.
         * @param {number} gridSize El tamaño de la cuadrícula.
         * @returns {Object} Un objeto con la cuadrícula generada y las palabras colocadas, o null si falla.
         */
        const generateCrosswordGrid = (wordsData, gridSize) => {
            const MAX_PLACEMENT_ATTEMPTS = 50;
            let bestGrid = null;
            let bestWords = [];
            let maxPlacedWords = 0;

            for (let attempt = 0; attempt < MAX_PLACEMENT_ATTEMPTS; attempt++) {
                let currentGrid = initializeGrid(gridSize);
                let currentPlacedWords = [];
                const shuffledWords = [...wordsData].sort(() => 0.5 - Math.random());

                // Intentar colocar la primera palabra en el centro
                const firstWordData = shuffledWords.shift();
                if (!firstWordData) continue;

                const firstWord = firstWordData.word.toUpperCase();
                const firstOrientation = Math.random() < 0.5 ? 'across' : 'down';
                const center = Math.floor(gridSize / 2);
                let startRow, startCol;
                
                if (firstOrientation === 'across') {
                    startRow = center;
                    startCol = center - Math.floor(firstWord.length / 2);
                } else {
                    startRow = center - Math.floor(firstWord.length / 2);
                    startCol = center;
                }
                
                const placement = { word: firstWord, clue: firstWordData.clue, start: { row: startRow, col: startCol }, direction: firstOrientation, isComplete: false };
                if (canPlaceWord(currentGrid, placement)) {
                    placeWord(currentGrid, placement);
                    currentPlacedWords.push(placement);
                } else {
                    continue; // No se pudo colocar la primera palabra, intentar de nuevo
                }

                // Intentar colocar el resto de las palabras buscando intersecciones
                for (const wordData of shuffledWords) {
                    const word = wordData.word.toUpperCase();
                    const possiblePlacements = findPossiblePlacements(currentGrid, word, wordData.clue, currentPlacedWords, gridSize);

                    if (possiblePlacements.length > 0) {
                        const bestPlacement = possiblePlacements.sort((a, b) => b.intersections - a.intersections)[0];
                        placeWord(currentGrid, bestPlacement);
                        currentPlacedWords.push(bestPlacement);
                    }
                }

                if (currentPlacedWords.length > maxPlacedWords) {
                    maxPlacedWords = currentPlacedWords.length;
                    bestGrid = currentGrid;
                    bestWords = currentPlacedWords;
                }
            }

            if (bestGrid && bestWords.length >= wordsData.length / 2) { // Considerar éxito si se coloca al menos la mitad
                // Asignar los números de pista
                bestWords.sort((a, b) => a.start.row - b.start.row || a.start.col - b.start.col);
                bestWords.forEach((wordObj, index) => {
                    wordObj.clueNumber = index + 1;
                    bestGrid[wordObj.start.row][wordObj.start.col].clueNumber = index + 1;
                });

                return { grid: bestGrid, words: bestWords };
            }

            return null; // Fallo al generar una cuadrícula viable
        };
        
        /**
         * Verifica si una palabra puede ser colocada en la cuadrícula sin conflictos.
         * @param {Array<Array<Object>>} grid La cuadrícula actual.
         * @param {Object} placement La información de la palabra a colocar.
         * @returns {boolean} Verdadero si se puede colocar, falso en caso contrario.
         */
        const canPlaceWord = (grid, placement) => {
            const { word, start, direction } = placement;
            const len = word.length;
            const size = grid.length;
            let intersectionCount = 0;

            if (direction === 'across') {
                if (start.col < 0 || start.col + len > size || start.row < 0 || start.row >= size) return false;
                if ((start.col > 0 && grid[start.row][start.col - 1].letter !== '') || (start.col + len < size && grid[start.row][start.col + len].letter !== '')) return false;

                for (let i = 0; i < len; i++) {
                    const cell = grid[start.row][start.col + i];
                    const letter = word[i];
                    if (cell.letter !== '' && cell.letter !== letter) return false;
                    if (cell.letter === letter) {
                        if (grid[start.row][start.col+i].clueNumber && grid[start.row][start.col+i].clueNumber !== null) continue; // Si es una celda de inicio de pista, no debe haber otra palabra cruzando.
                        intersectionCount++;
                    }

                    if (cell.letter === '') {
                        const above = start.row > 0 ? grid[start.row - 1][start.col + i].letter : '';
                        const below = start.row < size - 1 ? grid[start.row + 1][start.col + i].letter : '';
                        if (above !== '' || below !== '') return false;
                    }
                }
            } else { // 'down'
                if (start.row < 0 || start.row + len > size || start.col < 0 || start.col >= size) return false;
                if ((start.row > 0 && grid[start.row - 1][start.col].letter !== '') || (start.row + len < size && grid[start.row + len][start.col].letter !== '')) return false;

                for (let i = 0; i < len; i++) {
                    const cell = grid[start.row + i][start.col];
                    const letter = word[i];
                    if (cell.letter !== '' && cell.letter !== letter) return false;
                    if (cell.letter === letter) {
                        if (grid[start.row+i][start.col].clueNumber && grid[start.row+i][start.col].clueNumber !== null) continue;
                        intersectionCount++;
                    }
                    
                    if (cell.letter === '') {
                        const left = start.col > 0 ? grid[start.row + i][start.col - 1].letter : '';
                        const right = start.col < size - 1 ? grid[start.row + i][start.col + 1].letter : '';
                        if (left !== '' || right !== '') return false;
                    }
                }
            }
            return intersectionCount > 0 || grid.every(row => row.every(cell => cell.letter === ''));
        };
        
        /**
         * Coloca una palabra en la cuadrícula.
         * @param {Array<Array<Object>>} grid La cuadrícula a modificar.
         * @param {Object} placement La información de la palabra a colocar.
         */
        const placeWord = (grid, placement) => {
            const { word, start, direction } = placement;
            for (let i = 0; i < word.length; i++) {
                if (direction === 'across') {
                    grid[start.row][start.col + i].letter = word[i];
                } else {
                    grid[start.row + i][start.col].letter = word[i];
                }
            }
        };

        /**
         * Encuentra todas las posibles ubicaciones para una palabra en la cuadrícula.
         * @param {Array<Array<Object>>} grid La cuadrícula actual.
         * @param {string} word La palabra a colocar.
         * @param {string} clue La pista de la palabra.
         * @param {Array<Object>} placedWords Las palabras ya colocadas.
         * @param {number} gridSize El tamaño de la cuadrícula.
         * @returns {Array<Object>} Un array de posibles ubicaciones.
         */
        const findPossiblePlacements = (grid, word, clue, placedWords, gridSize) => {
            const placements = [];
            for (const placedWord of placedWords) {
                for (let i = 0; i < word.length; i++) {
                    for (let j = 0; j < placedWord.word.length; j++) {
                        if (word[i] === placedWord.word[j]) {
                            const newDirection = placedWord.direction === 'across' ? 'down' : 'across';
                            let startRow, startCol;

                            if (newDirection === 'across') {
                                startRow = placedWord.start.row + (placedWord.direction === 'down' ? j : 0);
                                startCol = placedWord.start.col + (placedWord.direction === 'across' ? j : 0) - i;
                            } else {
                                startRow = placedWord.start.row + (placedWord.direction === 'down' ? j : 0) - i;
                                startCol = placedWord.start.col + (placedWord.direction === 'across' ? j : 0);
                            }

                            const placement = { word, clue, start: { row: startRow, col: startCol }, direction: newDirection, isComplete: false };
                            if (canPlaceWord(grid, placement)) {
                                const intersections = getIntersections(grid, placement);
                                placements.push({ ...placement, intersections: intersections.length });
                            }
                        }
                    }
                }
            }
            return placements;
        };

        const getIntersections = (grid, placement) => {
            const { word, start, direction } = placement;
            const intersections = [];
            for (let i = 0; i < word.length; i++) {
                const row = direction === 'across' ? start.row : start.row + i;
                const col = direction === 'across' ? start.col + i : start.col;
                if (grid[row][col].letter === word[i]) {
                    intersections.push({ row, col });
                }
            }
            return intersections;
        };


        // Configuración de sonidos
        let synth = null;
        let panner = null;
        const initializeAudio = async () => {
             if (synth) return;
             await Tone.start();
             synth = new Tone.PolySynth(Tone.Synth).toDestination();
             panner = new Tone.Panner().toDestination();
        };

        const playSound = (type) => {
            if (!synth) return;
            let note = 'C4';
            let duration = '8n';
            switch (type) {
                case 'click':
                    note = 'C4';
                    duration = '32n';
                    synth.triggerAttackRelease(note, duration);
                    break;
                case 'error':
                    note = 'C2';
                    duration = '8n';
                    synth.triggerAttackRelease(note, duration);
                    break;
                case 'success':
                    note = 'E4';
                    duration = '8n';
                    synth.triggerAttackRelease(note, duration);
                    break;
                case 'wordComplete':
                    note = ['E4', 'G4', 'C5'];
                    duration = '8n';
                    synth.triggerAttackRelease(note, duration);
                    break;
            }
        };

        // Función para renderizar la pantalla principal
        const renderMainMenu = () => {
            const T = APP_CONFIG.languages[state.language];
            const appContainer = document.getElementById('app-container');
            appContainer.innerHTML = `
                <div class="flex flex-col items-center justify-center h-full text-center">
                    <h1 class="text-6xl md:text-8xl font-bold font-['Orbitron'] text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-fuchsia-600 mb-8 tracking-wider">
                        ${T.title}
                    </h1>
                    <div class="flex flex-col space-y-4 w-full max-w-sm">
                        <button id="play-btn" class="glassy-btn text-xl p-4 rounded-xl font-bold uppercase tracking-wide neon-text">
                            ${T.play}
                        </button>
                        <button id="options-btn" class="glassy-btn text-xl p-4 rounded-xl font-bold uppercase tracking-wide neon-text">
                            ${T.options}
                        </button>
                    </div>
                </div>
            `;
            document.getElementById('play-btn').addEventListener('click', () => {
                state.screen = 'gameModeSelect';
                renderScreen();
                playSound('click');
            });
            document.getElementById('options-btn').addEventListener('click', () => {
                state.screen = 'optionsMenu';
                renderScreen();
                playSound('click');
            });
        };
        
        // Función para renderizar la pantalla de opciones
        const renderOptionsMenu = () => {
            const T = APP_CONFIG.languages[state.language];
            const appContainer = document.getElementById('app-container');
            appContainer.innerHTML = `
                <div class="flex flex-col items-center justify-center h-full text-center">
                    <h2 class="text-3xl font-bold font-['Orbitron'] mb-8">${T.options}</h2>
                    <div class="flex flex-col space-y-4 w-full max-w-sm">
                        <div class="flex items-center justify-between glassy p-4 rounded-xl">
                            <label for="lang-select" class="text-lg">${T.langSelect}</label>
                            <select id="lang-select" class="bg-transparent border border-gray-500 rounded-md p-2">
                                <option value="es" ${state.language === 'es' ? 'selected' : ''}>Español</option>
                                <option value="en" ${state.language === 'en' ? 'selected' : ''}>English</option>
                            </select>
                        </div>
                        <div class="flex items-center justify-between glassy p-4 rounded-xl">
                            <label for="region-select" class="text-lg">${T.regionSelect}</label>
                            <select id="region-select" class="bg-transparent border border-gray-500 rounded-md p-2">
                                ${APP_CONFIG.languages[state.language].regionOptions.map(region => `
                                    <option value="${region}" ${state.region === region ? 'selected' : ''}>${region}</option>
                                `).join('')}
                            </select>
                        </div>
                        <button id="back-btn" class="glassy-btn text-xl p-4 rounded-xl font-bold uppercase tracking-wide neon-text mt-8">
                            ${T.backToMenu}
                        </button>
                    </div>
                </div>
            `;
            document.getElementById('lang-select').addEventListener('change', (e) => {
                state.language = e.target.value;
                renderScreen();
            });
            document.getElementById('back-btn').addEventListener('click', () => {
                state.screen = 'mainMenu';
                renderScreen();
                playSound('click');
            });
        };

        // Función para renderizar la pantalla de selección de modo de juego
        const renderGameModeSelect = () => {
            const T = APP_CONFIG.languages[state.language];
            const appContainer = document.getElementById('app-container');
            appContainer.innerHTML = `
                <div class="flex flex-col items-center justify-center h-full text-center">
                    <h2 class="text-3xl md:text-4xl font-bold font-['Orbitron'] text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-fuchsia-600 mb-8">
                        ${T.play}
                    </h2>
                    <div class="flex flex-col space-y-4 w-full max-w-sm">
                        <button id="casual-btn" class="glassy-btn text-xl p-4 rounded-xl font-bold uppercase tracking-wide neon-text">
                            ${T.casual}
                        </button>
                        <button id="survival-btn" class="glassy-btn text-xl p-4 rounded-xl font-bold uppercase tracking-wide neon-text">
                            ${T.survival}
                        </button>
                        <button id="back-btn" class="glassy-btn text-xl p-4 rounded-xl font-bold uppercase tracking-wide neon-text mt-8">
                            ${T.backToMenu}
                        </button>
                    </div>
                </div>
            `;
            document.getElementById('casual-btn').addEventListener('click', () => {
                state.gameMode = 'casual';
                state.screen = 'casualConfig';
                renderScreen();
                playSound('click');
            });
            document.getElementById('survival-btn').addEventListener('click', () => {
                state.gameMode = 'survival';
                state.screen = 'survivalConfig';
                renderScreen();
                playSound('click');
            });
            document.getElementById('back-btn').addEventListener('click', () => {
                state.screen = 'mainMenu';
                renderScreen();
                playSound('click');
            });
        };
        
        // Función para renderizar la configuración del modo casual
        const renderCasualConfig = () => {
            const T = APP_CONFIG.languages[state.language];
            const appContainer = document.getElementById('app-container');
            appContainer.innerHTML = `
                <div class="flex flex-col items-center justify-center h-full text-center">
                    <h2 class="text-3xl md:text-4xl font-bold font-['Orbitron'] text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-fuchsia-600 mb-8">
                        ${T.casual}
                    </h2>
                    <div class="flex flex-col space-y-4 w-full max-w-sm">
                        <div class="flex flex-col space-y-2 glassy p-4 rounded-xl">
                            <label for="category-select" class="text-lg">${T.selectCategory}</label>
                            <select id="category-select" class="bg-transparent border border-gray-500 rounded-md p-2">
                                ${APP_CONFIG.categories.map(cat => `<option value="${cat}">${cat}</option>`).join('')}
                            </select>
                        </div>
                        <div class="flex flex-col space-y-2 glassy p-4 rounded-xl">
                            <label for="difficulty-select" class="text-lg">${T.selectDifficulty}</label>
                            <select id="difficulty-select" class="bg-transparent border border-gray-500 rounded-md p-2">
                                ${APP_CONFIG.languages[state.language].difficultyLevels.map((level, i) => `<option value="${i + 1}">${level}</option>`).join('')}
                            </select>
                        </div>
                        <button id="start-game-btn" class="glassy-btn text-xl p-4 rounded-xl font-bold uppercase tracking-wide neon-text mt-8">
                            ${T.startGame}
                        </button>
                        <button id="back-btn" class="glassy-btn text-xl p-4 rounded-xl font-bold uppercase tracking-wide neon-text">
                            ${T.backToMenu}
                        </button>
                    </div>
                </div>
            `;
            document.getElementById('start-game-btn').addEventListener('click', async () => {
                state.category = document.getElementById('category-select').value;
                state.difficulty = parseInt(document.getElementById('difficulty-select').value);
                await startGame();
                playSound('click');
            });
            document.getElementById('back-btn').addEventListener('click', () => {
                state.screen = 'gameModeSelect';
                renderScreen();
                playSound('click');
            });
        };

        // Función para renderizar la configuración del modo supervivencia
        const renderSurvivalConfig = () => {
            const T = APP_CONFIG.languages[state.language];
            const appContainer = document.getElementById('app-container');
            appContainer.innerHTML = `
                <div class="flex flex-col items-center justify-center h-full text-center">
                    <h2 class="text-3xl md:text-4xl font-bold font-['Orbitron'] text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-fuchsia-600 mb-8">
                        ${T.survival}
                    </h2>
                    <div class="flex flex-col space-y-4 w-full max-w-sm">
                        <div class="flex flex-col space-y-2 glassy p-4 rounded-xl">
                            <label for="theme-input" class="text-lg">${T.enterTheme}</label>
                            <input id="theme-input" type="text" placeholder="${T.other}" class="bg-transparent border border-gray-500 rounded-md p-2 text-center" />
                        </div>
                        <button id="start-game-btn" class="glassy-btn text-xl p-4 rounded-xl font-bold uppercase tracking-wide neon-text mt-8">
                            ${T.startGame}
                        </button>
                        <button id="back-btn" class="glassy-btn text-xl p-4 rounded-xl font-bold uppercase tracking-wide neon-text">
                            ${T.backToMenu}
                        </button>
                    </div>
                </div>
            `;
            document.getElementById('start-game-btn').addEventListener('click', async () => {
                state.theme = document.getElementById('theme-input').value || APP_CONFIG.categories[0];
                state.level = 1;
                state.lives = APP_CONFIG.survivalLives;
                await startGame();
                playSound('click');
            });
            document.getElementById('back-btn').addEventListener('click', () => {
                state.screen = 'gameModeSelect';
                renderScreen();
                playSound('click');
            });
        };

        // Función principal para iniciar el juego
        const startGame = async () => {
            const T = APP_CONFIG.languages[state.language];
            // Mostrar un indicador de carga
            const appContainer = document.getElementById('app-container');
            appContainer.innerHTML = `<div class="flex flex-col items-center justify-center h-full text-center"><p class="text-3xl font-bold neon-text">${T.loading}</p></div>`;

            const theme = state.theme || state.category;
            const difficulty = state.difficulty;
            const language = state.language;

            const wordsData = await getWordsFromAI(theme, difficulty, language);
            
            if (wordsData.length === 0) {
                alert(T.noWords);
                state.screen = 'mainMenu';
                renderScreen();
                return;
            }

            const crossword = generateCrosswordGrid(wordsData, APP_CONFIG.gridSize);

            if (!crossword || crossword.words.length === 0) {
                // Si la generación del crucigrama falla, intentarlo de nuevo.
                console.error("Fallo al generar el crucigrama. Reintentando...");
                alert("Error al generar el crucigrama. Por favor, inténtalo de nuevo.");
                state.screen = 'mainMenu';
                renderScreen();
                return;
            }
            
            state.words = crossword.words;
            state.grid = crossword.grid;
            state.aidsLeft = APP_CONFIG.maxAids;
            state.errors = 0;
            state.timer = 0;
            state.screen = 'game';
            
            // Iniciar el temporizador
            if (state.timerInterval) clearInterval(state.timerInterval);
            state.timerInterval = setInterval(() => {
                state.timer++;
                const timerElement = document.getElementById('timer-val');
                if (timerElement) {
                    timerElement.textContent = formatTime(state.timer);
                }
            }, 1000);
            renderScreen();
        };

        const formatTime = (seconds) => {
            const min = Math.floor(seconds / 60);
            const sec = seconds % 60;
            return `${min}:${sec < 10 ? '0' : ''}${sec}`;
        };

        const checkWinCondition = () => {
            const allWordsComplete = state.words.every(word => word.isComplete);
            if (allWordsComplete) {
                if (state.gameMode === 'casual') {
                    renderWinScreen();
                } else if (state.gameMode === 'survival') {
                    state.level++;
                    renderWinScreen();
                }
            }
        };

        const renderWinScreen = () => {
            clearInterval(state.timerInterval);
            state.screen = 'win';
            renderScreen();
        };

        // Renderiza la pantalla del juego
        const renderGame = () => {
            const T = APP_CONFIG.languages[state.language];
            const appContainer = document.getElementById('app-container');
            const gameTitle = state.gameMode === 'casual' ? `${T.category}: ${state.category} (Nivel ${state.difficulty})` : `${T.theme}: ${state.theme} (Nivel ${state.level})`;
            appContainer.innerHTML = `
                <div class="flex flex-col h-full text-center">
                    <h2 class="text-3xl md:text-4xl font-bold font-['Orbitron'] text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-fuchsia-600 mb-8">${gameTitle}</h2>
                    <div class="flex flex-col md:flex-row space-y-4 md:space-y-0 md:space-x-8 h-full">
                        <!-- Panel del juego (izquierda) -->
                        <div class="flex-grow w-full md:w-1/2 flex flex-col items-center">
                            <div id="game-info" class="flex justify-between w-full mb-4 px-2 text-sm md:text-base">
                                <span class="flex items-center"><span class="mr-1">${T.timer}</span> <span id="timer-val" class="font-bold">0:00</span></span>
                                ${state.gameMode === 'survival' ? `
                                    <span class="flex items-center"><span class="mr-1">${T.lives}</span> <span id="lives-val" class="font-bold">${state.lives}</span></span>
                                ` : `
                                    <span class="flex items-center"><span class="mr-1">${T.errors}</span> <span id="errors-val" class="font-bold">${state.errors}</span></span>
                                `}
                            </div>
                            <!-- Tablero de crucigramas -->
                            <div id="crossword-grid" class="grid-container w-full aspect-square bg-gray-900 rounded-xl p-1 md:p-2">
                                <!-- Las celdas se generarán aquí -->
                            </div>
                        </div>
                        <!-- Panel de pistas (derecha) -->
                        <div class="w-full md:w-1/2 flex flex-col space-y-4">
                            <div id="clues-panel" class="flex-grow w-full h-96 md:h-full glassy p-4 rounded-xl overflow-y-auto no-scrollbar">
                                <div class="mb-4">
                                    <h3 class="font-bold text-xl mb-2">${T.horizontal}</h3>
                                    <ul id="across-clues" class="list-disc list-inside space-y-1"></ul>
                                </div>
                                <div>
                                    <h3 class="font-bold text-xl mb-2">${T.vertical}</h3>
                                    <ul id="down-clues" class="list-disc list-inside space-y-1"></ul>
                                </div>
                            </div>
                            <!-- Panel de ayuda -->
                            <div class="flex items-center space-x-2 w-full">
                                <button id="help-btn" class="flex-grow glassy-btn text-sm p-3 rounded-xl font-bold uppercase tracking-wide disabled:opacity-50 disabled:cursor-not-allowed">
                                    ${T.helpIA} (${T.aidsLeft} <span id="aids-val">${state.aidsLeft}</span>)
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            const gridContainer = document.getElementById('crossword-grid');
            if (!gridContainer) return;
            
            gridContainer.style.gridTemplateColumns = `repeat(${APP_CONFIG.gridSize}, minmax(0, 1fr))`;
            gridContainer.style.gridTemplateRows = `repeat(${APP_CONFIG.gridSize}, minmax(0, 1fr))`;
            gridContainer.classList.add('grid', 'gap-1');

            const acrossCluesList = document.getElementById('across-clues');
            const downCluesList = document.getElementById('down-clues');

            if (acrossCluesList && downCluesList) {
                acrossCluesList.innerHTML = '';
                downCluesList.innerHTML = '';
            }

            state.words.forEach((wordObj, wordIndex) => {
                const clueElement = document.createElement('li');
                clueElement.id = `clue-${wordIndex}`;
                clueElement.className = 'cursor-pointer hover:text-cyan-400 transition-colors duration-200';
                clueElement.textContent = `(${wordObj.clueNumber}) ${wordObj.clue}`;
                clueElement.addEventListener('click', () => {
                    selectWord(wordIndex);
                    playSound('click');
                });
                
                if (wordObj.direction === 'across') {
                    if (acrossCluesList) acrossCluesList.appendChild(clueElement);
                } else {
                    if (downCluesList) downCluesList.appendChild(clueElement);
                }
            });

            for (let row = 0; row < APP_CONFIG.gridSize; row++) {
                for (let col = 0; col < APP_CONFIG.gridSize; col++) {
                    const cell = state.grid[row][col];
                    const cellElement = document.createElement('div');
                    cellElement.className = 'cell bg-gray-800 rounded-sm hover:bg-gray-700 transition-colors duration-200 cursor-pointer';
                    cellElement.dataset.row = row;
                    cellElement.dataset.col = col;

                    const cellInner = document.createElement('div');
                    cellInner.className = 'cell-inner';

                    if (cell.letter !== '') {
                        const inputElement = document.createElement('input');
                        inputElement.type = 'text';
                        inputElement.maxLength = 1;
                        inputElement.className = 'w-full h-full text-center bg-transparent focus:outline-none';
                        inputElement.value = cell.input;
                        inputElement.readOnly = false;
                        inputElement.addEventListener('input', (e) => handleInput(e, row, col));
                        cellInner.appendChild(inputElement);
                        
                        if (cell.clueNumber) {
                            const clueNumber = document.createElement('div');
                            clueNumber.className = 'absolute top-0 left-1 text-xs text-gray-400 font-bold';
                            clueNumber.textContent = cell.clueNumber;
                            cellElement.appendChild(clueNumber);
                        }

                        cellElement.addEventListener('click', () => {
                           selectCell(row, col);
                           playSound('click');
                        });
                    } else {
                        cellElement.classList.add('bg-gray-900', 'cursor-not-allowed');
                    }

                    cellElement.appendChild(cellInner);
                    gridContainer.appendChild(cellElement);
                }
            }
            
            document.getElementById('help-btn').addEventListener('click', () => {
                if (state.aidsLeft > 0) {
                    useAid();
                } else {
                    alert('No tienes más ayudas disponibles.');
                }
            });
            
            // Renderiza el tablero por primera vez
            renderGrid();
        };

        const renderWinLossScreen = (isWin) => {
            const T = APP_CONFIG.languages[state.language];
            const appContainer = document.getElementById('app-container');
            const title = isWin ? T.winTitle : T.gameOverTitle;
            const message = isWin ? T.winMessage : T.gameOverMessage;
            
            appContainer.innerHTML = `
                <div class="flex flex-col items-center justify-center h-full text-center">
                    <h2 class="text-5xl font-bold font-['Orbitron'] text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-fuchsia-600 mb-4">${title}</h2>
                    <p class="text-xl mb-8">${message}</p>
                    ${state.gameMode === 'survival' && isWin ? `
                        <p class="text-lg mb-4">Nivel completado: ${state.level - 1}</p>
                        <p class="text-lg mb-8">Preparándote para el Nivel ${state.level}...</p>
                        <button id="next-level-btn" class="glassy-btn text-xl p-4 rounded-xl font-bold uppercase tracking-wide neon-text">
                            ${T.nextLevel}
                        </button>
                    ` : `
                        <div class="flex flex-col space-y-4 w-full max-w-sm">
                            <button id="restart-btn" class="glassy-btn text-xl p-4 rounded-xl font-bold uppercase tracking-wide neon-text">
                                ${T.restart}
                            </button>
                            <button id="back-to-menu-btn" class="glassy-btn text-xl p-4 rounded-xl font-bold uppercase tracking-wide neon-text">
                                ${T.backToMenu}
                            </button>
                        </div>
                    `}
                </div>
            `;

            if (state.gameMode === 'survival' && isWin) {
                document.getElementById('next-level-btn').addEventListener('click', async () => {
                    await startGame();
                });
            } else {
                document.getElementById('restart-btn').addEventListener('click', async () => {
                    state.level = 1;
                    state.lives = APP_CONFIG.survivalLives;
                    await startGame();
                });
                document.getElementById('back-to-menu-btn').addEventListener('click', () => {
                    state.screen = 'mainMenu';
                    renderScreen();
                });
            }
        };

        const renderScreen = () => {
            const T = APP_CONFIG.languages[state.language];
            const appContainer = document.getElementById('app-container');
            appContainer.innerHTML = '';
            
            // Generar las barras de neón de fondo
            const animatedBg = document.querySelector('.animated-bg');
            if (animatedBg.children.length === 0) {
                for(let i = 0; i < 20; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'neon-bar';
                    bar.style.left = `${Math.random() * 100}vw`;
                    bar.style.animationDuration = `${5 + Math.random() * 15}s`;
                    bar.style.animationDelay = `-${Math.random() * 10}s`;
                    animatedBg.appendChild(bar);
                }
            }

            switch (state.screen) {
                case 'mainMenu':
                    renderMainMenu();
                    break;
                case 'optionsMenu':
                    renderOptionsMenu();
                    break;
                case 'gameModeSelect':
                    renderGameModeSelect();
                    break;
                case 'casualConfig':
                    renderCasualConfig();
                    break;
                case 'survivalConfig':
                    renderSurvivalConfig();
                    break;
                case 'game':
                    renderGame();
                    break;
                case 'win':
                    renderWinLossScreen(true);
                    break;
                case 'gameOver':
                    renderWinLossScreen(false);
                    break;
            }
        };

        const selectCell = (row, col) => {
            state.selectedCell = { row, col };
            state.selectedWord = null;
            
            // Resaltar celdas seleccionadas
            document.querySelectorAll('.cell-selected').forEach(el => el.classList.remove('cell-selected', 'bg-cyan-400', 'bg-fuchsia-600'));
            
            const cellElement = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            if (cellElement) {
                cellElement.classList.add('cell-selected', 'bg-cyan-400');
                const input = cellElement.querySelector('input');
                if (input) input.focus();
            }

            // Encontrar palabras que pasan por la celda
            const acrossWord = state.words.find(w => 
                w.direction === 'across' && 
                row === w.start.row && 
                col >= w.start.col && 
                col < w.start.col + w.word.length
            );

            const downWord = state.words.find(w => 
                w.direction === 'down' && 
                col === w.start.col && 
                row >= w.start.row && 
                row < w.start.row + w.word.length
            );

            if (acrossWord) {
                highlightWord(acrossWord, 'across');
            }
            if (downWord) {
                highlightWord(downWord, 'down');
            }
        };

        const selectWord = (wordIndex) => {
            const wordObj = state.words[wordIndex];
            if (!wordObj) return;

            state.selectedWord = wordIndex;
            state.selectedCell = { row: wordObj.start.row, col: wordObj.start.col };

            document.querySelectorAll('.clue-selected').forEach(el => el.classList.remove('clue-selected', 'font-bold', 'text-cyan-400'));
            const clueElement = document.getElementById(`clue-${wordIndex}`);
            if (clueElement) {
                clueElement.classList.add('clue-selected', 'font-bold', 'text-cyan-400');
            }
            
            highlightWord(wordObj, 'all');

            const firstCellElement = document.querySelector(`[data-row="${wordObj.start.row}"][data-col="${wordObj.start.col}"]`);
            if (firstCellElement) {
                const input = firstCellElement.querySelector('input');
                if (input) input.focus();
            }
        };

        const highlightWord = (wordObj, type) => {
            const { word, start, direction } = wordObj;
            document.querySelectorAll('.cell-highlighted').forEach(el => el.classList.remove('cell-highlighted', 'bg-cyan-900'));
            for (let i = 0; i < word.length; i++) {
                const row = direction === 'across' ? start.row : start.row + i;
                const col = direction === 'across' ? start.col + i : start.col;
                const cellElement = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                if (cellElement && !cellElement.classList.contains('cell-selected')) {
                    cellElement.classList.add('cell-highlighted', 'bg-cyan-900');
                }
            }
        };

        const handleInput = (e, row, col) => {
            const input = e.target;
            const value = input.value.toUpperCase();
            input.value = value;
            
            const cell = state.grid[row][col];
            if (cell.letter === '') return;

            cell.input = value;

            // Encontrar la palabra horizontal
            const acrossWord = state.words.find(w => 
                w.direction === 'across' && 
                row === w.start.row && 
                col >= w.start.col && 
                col < w.start.col + w.word.length
            );

            // Encontrar la palabra vertical
            const downWord = state.words.find(w => 
                w.direction === 'down' && 
                col === w.start.col && 
                row >= w.start.row && 
                row < w.start.row + w.word.length
            );

            // Validar la palabra y avanzar el cursor
            const validateWordAndMoveCursor = (wordObj) => {
                if (!wordObj || wordObj.isComplete) return;

                const currentWordCells = [];
                let isWordComplete = true;
                let isWordCorrect = true;

                for (let i = 0; i < wordObj.word.length; i++) {
                    const r = wordObj.direction === 'across' ? wordObj.start.row : wordObj.start.row + i;
                    const c = wordObj.direction === 'across' ? wordObj.start.col + i : wordObj.start.col;
                    
                    const cell = state.grid[r][c];
                    const cellElement = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                    const cellInput = cellElement ? cellElement.querySelector('input') : null;

                    if (!cellInput || cellInput.value === '') {
                        isWordComplete = false;
                        isWordCorrect = false;
                        break;
                    }

                    if (cellInput.value !== cell.letter) {
                        isWordCorrect = false;
                    }
                    currentWordCells.push(cellInput);
                }

                if (isWordComplete) {
                    if (isWordCorrect) {
                        wordObj.isComplete = true;
                        playSound('wordComplete');
                        currentWordCells.forEach(input => {
                            input.classList.remove('incorrect');
                            input.classList.add('correct');
                            input.readOnly = true;
                            const cellElement = input.closest('.cell');
                            if (cellElement) cellElement.classList.add('complete');
                        });
                        const clueElement = document.getElementById(`clue-${state.words.indexOf(wordObj)}`);
                        if(clueElement) clueElement.classList.add('line-through');
                        checkWinCondition();
                    } else {
                        playSound('error');
                        state.errors++;
                        const errorsVal = document.getElementById('errors-val');
                        if (errorsVal) errorsVal.textContent = state.errors;
                        
                        if (state.gameMode === 'survival') {
                            state.lives--;
                            const livesVal = document.getElementById('lives-val');
                            if (livesVal) livesVal.textContent = state.lives;
                            if (state.lives <= 0) {
                                clearInterval(state.timerInterval);
                                state.screen = 'gameOver';
                                renderScreen();
                            }
                        }
                    }
                }

                // Mover el cursor a la siguiente celda
                if (value !== '') {
                    let nextRow = row;
                    let nextCol = col;
                    if (wordObj.direction === 'across') {
                        nextCol++;
                    } else {
                        nextRow++;
                    }
                    
                    const nextCell = document.querySelector(`[data-row="${nextRow}"][data-col="${nextCol}"]`);
                    if (nextCell) {
                        const nextInput = nextCell.querySelector('input');
                        if (nextInput && !nextInput.readOnly) {
                            nextInput.focus();
                        }
                    }
                }
            };
            
            // Validar ambas palabras si la celda es un cruce
            validateWordAndMoveCursor(acrossWord);
            validateWordAndMoveCursor(downWord);
        };
        
        const useAid = () => {
            const T = APP_CONFIG.languages[state.language];
            if (state.aidsLeft <= 0 || !state.selectedCell) {
                alert('No tienes más ayudas o ninguna celda seleccionada.');
                return;
            }

            const { row, col } = state.selectedCell;
            const cell = state.grid[row][col];
            if (cell.input !== '') {
                alert('La celda ya está llena.');
                return;
            }
            
            state.aidsLeft--;
            const aidsVal = document.getElementById('aids-val');
            if(aidsVal) aidsVal.textContent = state.aidsLeft;
            
            cell.input = cell.letter;
            const cellElement = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            if (cellElement) {
                const input = cellElement.querySelector('input');
                if (input) {
                    input.value = cell.letter;
                    input.readOnly = true;
                    input.classList.remove('incorrect');
                    input.classList.add('correct');
                }
            }
            playSound('success');

            // Verificar si alguna palabra se ha completado con la ayuda
            state.words.forEach(wordObj => {
                if (!wordObj.isComplete) {
                    const isWordCompleteWithAid = [...wordObj.word].every((letter, i) => {
                        const r = wordObj.direction === 'across' ? wordObj.start.row : wordObj.start.row + i;
                        const c = wordObj.direction === 'across' ? wordObj.start.col + i : wordObj.start.col;
                        const gridCell = state.grid[r][c];
                        return gridCell.input !== '';
                    });

                    if (isWordCompleteWithAid) {
                        wordObj.isComplete = true;
                        const clueElement = document.getElementById(`clue-${state.words.indexOf(wordObj)}`);
                        if(clueElement) clueElement.classList.add('line-through');
                        checkWinCondition();
                    }
                }
            });
            
        };

        const renderGrid = () => {
            const gridContainer = document.getElementById('crossword-grid');
            if (!gridContainer) return;
            
            const cellElements = gridContainer.querySelectorAll('.cell');
            cellElements.forEach(cellElement => {
                const row = parseInt(cellElement.dataset.row);
                const col = parseInt(cellElement.dataset.col);
                const cell = state.grid[row][col];
                
                const input = cellElement.querySelector('input');
                if (input) {
                    input.value = cell.input;
                    if (cell.input !== '' && cell.input === cell.letter) {
                       input.classList.add('correct');
                       input.readOnly = true;
                    }
                    if (cell.input !== '' && cell.input !== cell.letter) {
                        input.classList.add('incorrect');
                    }
                }
            });
        };

        // Inicializar la aplicación
        window.onload = () => {
            renderScreen();
            initializeAudio();
        };

    </script>
</body>
</html>
